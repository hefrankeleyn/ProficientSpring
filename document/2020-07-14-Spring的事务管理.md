# Spring的事务管理

[toc]

## 一、数据库事务

### 1.1 数据库事务的四个特性

- 原子性
- **一致性**（一致性是最终目标）
- 隔离性
- 持久性

### 1.2 数据并发的问题

- 脏读（A事务读取B事务尚未提交的更改数据）
- 不可重复读（A事务读取了B事务已经提交的更改数据）
- 幻象读（A事务读取了B事务提交的新增数据）
- 第一类丢失更新（A事务撤销时，把已经提交的B事务的更新数据覆盖了）
- 第二类丢失更新（A事务覆盖了B事务已经提交的数据，造成B事务所做的操作丢失）

### 1.3 数据库锁机制

按锁定的对象的不同：

- 表锁定：对整张表进行锁定
- 行锁定：对表中的特定行进行锁定

从并发事务锁定的关系上看

- 共享锁定
- 独占锁定

### 1.4 事务的隔离级别

- read uncommited
- read commited
- repeatable read
- serializable

隔离级别和并发性是对立的。

### 1.5 JDBC对事务的支持

- 不是所有的数据库都支持事务
- 支持事务的数据库并非支持所有的事务隔离级别

## 二、`ThreadLocal`

`ThreadLocal`为每个使用该变量的线程分配一个独立的变量副本。

### 2.1 与Thread同步机制的比较

对于多线程资源共享的问题，同步机制采用“以时间换空间”的方式，访问串行化，对象共享化；而ThreadLocal采用了“以空间换时间”的方式，访问并行化，对象独享化。

## 三、Spring的事务传播

事务传播是Spring进行事务管理的重要概念。

Spring在`TransactionDefinition`中规定了7种类型的事务传播行为：

- `PROPAGATION_REQUIRED` 如果当前没有事务，则新建一个事务；如果已经存在一个事务，则加入到这个事务中，这是最常见的选择。
- `PROPAGATION_SUPPORTS` 支持当前事务，如果当前没有事务，则以非事务方式执行；
- `PROPAGATION_MANDATORY` 使用当前事务，如果当前没有事务，则抛出异常；
- `PROPAGATION_REQUIRES_NEW` 新建事务，如果当前存在事务，则将当前事务挂起；
- `PROPAGATION_NOT_SUPPORTED` 以非事务方式执行操作，如果当前存在事务，则把当前事务挂起；
- `PROPAGATION_NEVER` 以非事务方式执行。如果当前存在事务，则抛出异常；
- `PROPAGATION_NESTED`如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与`PROPAGATION_REQUIRED`类似的操作。

## 四、事务配置

### 4.1 使用原始的`TransactionProxyFactoryBean`

### 4.2 基于AOP/tx命名空间的配置

### 4.3 使用注解配置声明式事务

